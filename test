/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 13:58:59 by morgane          #+#    #+#             */
/*   Updated: 2025/01/07 08:17:55 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
#include "libft.h"
#include "mlx.h"
#include "map_parser.h"
#include "player.h"
#include "renderer.h"
#include "so_long.h"
#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <X11/X.h>
#include "score.h"

int	loop(t_game_data *data)
{
	if ((data->game_flags & GF_NEED_WORLD_REFRESH) != 0)
		render_world(data);
	if ((data->game_flags & GF_GAME_OBJECTIVE_WON) != 0)
		clean_up(data, 0);
	tick_enemies(data);
	draw_score(data);
	return (0);
}

int	manage_inputs(int keycode, t_game_data *data)
{
	if (keycode == ESC)
		clean_up(data, 0);
	data->can_step = 1;
	if (keycode == UP_W || keycode == UP_W_A || keycode == UP_S
		|| keycode == UP_S_A || keycode == UP_A || keycode == UP_A_A
		|| keycode == UP_D || keycode == UP_D_A)
	{
		handle_player_inputs(keycode, data);
		if (data->game_flags & GF_PLAYER_IS_MOVING)
		{
			update_player_pos(data);
			++data->player_step;
			ft_printf("Player has taken %d steps.\n", data->player_step);
		}
	}
	else
		ft_printf("key pressed: %d\n\n", keycode);
	return (0);
}

int	setup_textures(t_game_data *data);

static t_vector2i	map_size(char **map)
{
	t_vector2i	_map;

	_map.x = ft_strlen(map[0]) * 32;
	_map.y = -1;
	while (map[++_map.y] != NULL)
	{
	}
	_map.y *= 32;
	_map.y += (32 * (IS_BONUS * 2));
	if (_map.x <= 400)
		_map.x = 400;
	return (_map);
}

// valgrind is being a cunt over this.
void	reset_all(t_game_data *data)
{
	t_vector2i	map_size;

	map_size.x = 0;
	map_size.y = 0;
	data->game_flags = 0;
	data->enemy_count = 0;
	data->player_step = 0;
	data->base_collectible = 0;
	data->collectible_count = 0;
	data->map_size = map_size;
	data->player_pos = map_size;
	data->mlx = NULL;
	data->mlx_win = NULL;
}

int	int_c_up(t_game_data *data);

int	main(int argc, char **argv)
{
	t_game_data	g_data;

	reset_all(&g_data);
	if (argc == 1)
		return (ft_error("Please input a map file", -2, &g_data));
	if (!ft_strend(argv[1], ".ber"))
		return (ft_error("Map file must have .ber extention !", -2, &g_data));
	g_data.mlx = mlx_init();
	if (!setup_textures(&g_data))
		return (ft_error("Textures could not be loaded", -1, &g_data));
	g_data.map_data = read_map(argv[1]);
	if (g_data.map_data == NULL)
		return (ft_error("Could not load map !", 1, &g_data));
	g_data.mlx_win = mlx_new_window(g_data.mlx, map_size(g_data.map_data).x,
			map_size(g_data.map_data).y, "Hello world!");
	if (!validate_map(&g_data))
		return (ft_error("Invalid map data", 0, &g_data));
	figure_out_player_pos(&g_data);
	mlx_key_hook(g_data.mlx_win, manage_inputs, &g_data);
	mlx_hook(g_data.mlx_win, DestroyNotify, ButtonPressMask, int_c_up, &g_data);
	mlx_loop_hook(g_data.mlx, loop, &g_data);
	mlx_loop(g_data.mlx);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_leak.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 13:34:37 by morgane          #+#    #+#             */
/*   Updated: 2024/12/03 13:44:53 by morgane         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include "map_parser.h"

static int	is_wall_or_eol(char id)
{
	return (id == '1' || id == '\n');
}

int	map_leak_to_void(t_game_data *data, t_infos *infos)
{
	t_vector2i	tmp;

	tmp.y = 0;
	infos->map_x = ft_strlen(data->map_data[tmp.y]);
	while (tmp.y < infos->map_y)
	{
		tmp.x = 0;
		if (tmp.y == 0 || tmp.y == infos->map_y - 1)
		{
			while (data->map_data[tmp.y][tmp.x])
			{
				if (!is_wall_or_eol(data->map_data[tmp.y][tmp.x]))
					return (0);
				++tmp.x;
			}
		}
		else if (!is_wall_or_eol(data->map_data[tmp.y][0])
				|| !is_wall_or_eol(data->map_data[tmp.y][infos->map_x - 1]))
			return (0);
		++tmp.y;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:01:46 by morgane          #+#    #+#             */
/*   Updated: 2024/12/03 14:01:51 by morgane         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"
#include "libft.h"
#include <stdio.h>
#include <stdlib.h>

void		fill_str(char *res, char *s1, char *s2);

static char	*read_buffer(char *buffer)
{
	char	*left_over;
	ssize_t	i;

	i = 0;
	while (buffer[i] != '\n' && buffer[i] != '\0')
		i++;
	if (buffer[i] == 0 || buffer[1] == 0)
		return (NULL);
	left_over = ft_substr(buffer, i + 1, ft_strlen(buffer) - i);
	if (*left_over == 0)
	{
		free(left_over);
		left_over = NULL;
	}
	buffer[i + 1] = 0;
	return (left_over);
}

static char	*feed_buffer(int fd, char *left_over, char *buffer)
{
	ssize_t	reddit;
	char	*tmp;

	reddit = 1;
	while (reddit > 0)
	{
		reddit = read(fd, buffer, BUFFER_SIZE);
		if (reddit == -1)
			return (free(left_over), NULL);
		else if (reddit == 0)
			break ;
		buffer[reddit] = 0;
		if (!left_over)
			left_over = ft_strdup("");
		tmp = ft_strjoin(left_over, buffer);
		free(left_over);
		left_over = tmp;
		if (ft_strchr(buffer, '\n'))
			break ;
	}
	return (left_over);
}

char	*get_next_line(int fd)
{
	static char	*left_over;
	char		*line;
	char		*buffer;

	buffer = (char *)malloc((BUFFER_SIZE + 1) * sizeof(char));
	if (fd < 0 || BUFFER_SIZE <= 0 || read(fd, 0, 0) < 0)
	{
		free(left_over);
		free(buffer);
		left_over = NULL;
		buffer = NULL;
		return (NULL);
	}
	if (!buffer)
		return (free(left_over), left_over = NULL, NULL);
	line = feed_buffer(fd, left_over, buffer);
	free(buffer);
	buffer = NULL;
	if (!line)
		return (free(left_over), left_over = NULL, buffer = NULL, NULL);
	left_over = read_buffer(line);
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_parser.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:02:31 by morgane          #+#    #+#             */
/*   Updated: 2025/01/06 14:12:05 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"
#include "libft.h"
#include "map_parser.h"
#include <fcntl.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

int	ft_strend(const char *target, const char *end)
{
	size_t	end_size;
	size_t	target_size;

	end_size = ft_strlen(end);
	target_size = ft_strlen(target);
	if (target_size < end_size)
		return (0);
	while (end_size != 0)
	{
		if (target[target_size] != end[end_size])
			return (0);
		--end_size;
		--target_size;
	}
	return (1);
}

static int	check(int fd)
{
	return (fd > 0 && read(fd, 0, 0) >= 0);
}

int	get_line_count(int fd)
{
	int		lines;
	char	*tmp;

	if (!check(fd))
		return (-1);
	tmp = get_next_line(fd);
	lines = 0;
	while (tmp != NULL)
	{
		free(tmp);
		tmp = get_next_line(fd);
		++lines;
	}
	close(fd);
	return (lines);
}

// read file at *path, and return a NULL-terminated **char
char	**read_map(char *path)
{
	char	**map_data;
	char	*cline;
	int		fd;
	int		lines;
	int		tmp;

	fd = open(path, O_RDONLY);
	if (fd == -1)
		return (NULL);
	lines = get_line_count(fd);
	if (lines == -1)
		return (NULL);
	map_data = (char **)ft_calloc(sizeof(char **), (lines + 1));
	fd = open(path, O_RDONLY);
	cline = get_next_line(fd);
	tmp = 0;
	while (tmp < lines)
	{
		map_data[tmp] = cline;
		cline = get_next_line(fd);
		map_data[tmp][ft_strlen(map_data[tmp]) - 1] = '\0';
		++tmp;
	}
	return (close(fd), map_data[lines] = NULL, map_data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   floodfill.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:02:12 by morgane          #+#    #+#             */
/*   Updated: 2025/01/06 15:23:46 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "map_parser.h"
#include <unistd.h>
#include "renderer.h"

static void	reset_map(t_game_data *data)
{
	t_vector2i	pos;

	pos.y = -1;
	while (++pos.y < data->map_size.y)
	{
		pos.x = -1;
		while (++pos.x < data->map_size.x)
		{
			if (data->map_data[pos.y][pos.x] == 'V')
				data->map_data[pos.y][pos.x] = '0';
			if (data->map_data[pos.y][pos.x] == 'T')
				data->map_data[pos.y][pos.x] = 'C';
		}
	}
}

static int			flood_fill(t_game_data *data, t_vector2i origin, int *found,
				int fla);

static int	internal_flood_fill(t_game_data *data, t_vector2i origin,
		int *found, int flag)
{
	int	tmp;

	tmp = flood_fill(data, vector_add_lit(origin, 1, 0), found, flag);
	if (tmp)
		return (1);
	tmp = flood_fill(data, vector_add_lit(origin, 0, 1), found, flag);
	if (tmp)
		return (1);
	tmp = flood_fill(data, vector_add_lit(origin, -1, 0), found, flag);
	if (tmp)
		return (1);
	tmp = flood_fill(data, vector_add_lit(origin, 0, -1), found, flag);
	if (tmp)
		return (1);
	return (0);
}

static int	flood_fill(t_game_data *data, t_vector2i origin, int *found,
		int fla)
{
	if (0)
		render_world(data);
	if (origin.x < 0 || origin.x >= data->map_size.x || origin.y < 0
		|| origin.y >= data->map_size.y)
		return (0);
	if (fla == 1 && *found == data->collectible_count)
		return (1);
	else if (fla == 0 && data->map_data[origin.y][origin.x] == 'P')
		return (1);
	if (data->map_data[origin.y][origin.x] == '1'
		|| (data->map_data[origin.y][origin.x] == 'V'
			|| data->map_data[origin.y][origin.x] == 'T')
		|| (*found >= data->collectible_count))
		return (0);
	if (data->map_data[origin.y][origin.x] == 'C')
	{
		*found += fla;
		data->map_data[origin.y][origin.x] = 'T';
	}
	else if (data->map_data[origin.y][origin.x] == '0')
		data->map_data[origin.y][origin.x] = 'V';
	return (internal_flood_fill(data, origin, found, fla));
}

static t_vector2i	figure_out_exit_pos(t_game_data *data)
{
	t_vector2i	pos;
	t_vector2i	invalid;

	invalid.x = -1;
	invalid.y = -1;
	pos.y = -1;
	while (++pos.y < data->map_size.y)
	{
		pos.x = -1;
		while (++pos.x < data->map_size.x)
			if (data->map_data[pos.y][pos.x] == 'E')
				return (pos);
	}
	return (invalid);
}

int	is_exit_available(t_game_data *data, t_infos *infos)
{
	t_vector2i	exit_pos;
	int			found_count;

	found_count = 0;
	data->map_size.x = infos->map_x;
	data->map_size.y = infos->map_y;
	exit_pos = figure_out_exit_pos(data);
	if (!flood_fill(data, exit_pos, &found_count, 0))
		return (0);
	reset_map(data);
	found_count = 0;
	flood_fill(data, exit_pos, &found_count, 1);
	if (found_count != data->collectible_count)
		return (0);
	reset_map(data);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validator.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:02:58 by morgane          #+#    #+#             */
/*   Updated: 2025/01/07 07:51:43 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include "map_parser.h"
#include <stdio.h>
#include "renderer.h"
#include "so_long.h"
#include "utils.h"

static int	is_uniq_tile(unsigned int mask, int *container)
{
	if ((*container & mask) != 0)
		return (0);
	*container ^= mask;
	return (1);
}

static int	mask_to_id(char id)
{
	if (id == 'P')
		return (1 << 0);
	if (id == 'E')
		return (1 << 1);
	return (0);
}

static int	line_count(t_game_data *d, t_infos *i)
{
	char	**map;
	int		size_y;
	int		size_x;

	map = d->map_data;
	d->collectible_count = 0;
	d->enemy_count = 0;
	size_y = 0;
	while (map[size_y] != NULL)
	{
		size_x = -1;
		while (map[size_y][++size_x])
		{
			if (map[size_y][size_x] == 'C')
				d->collectible_count++;
			if (map[size_y][size_x] == 'E')
				d->exit = &map[size_y][size_x];
			if (map[size_y][size_x] == 'F')
				d->enemy_count++;
		}
		++size_y;
	}
	return (i->map_y = size_y, i->map_x = ft_strlen(d->map_data[0]), size_y);
}

static int	scan_map(t_game_data *d, t_infos *i)
{
	t_vector2i	pos;

	while (++i->y < i->map_y)
	{
		pos.y = i->y;
		i->x = -1;
		if ((int)ft_strlen(d->map_data[i->y]) != i->map_x)
			return (0);
		while (d->map_data[i->y][++i->x])
		{
			pos.x = i->x;
			if (!is_valid_id(d->map_data[i->y][i->x]))
				return (0);
			if (d->map_data[i->y][i->x] == 'F')
				spawn_enemies(d, pos);
			if (d->map_data[i->y][i->x] == 'P'
				|| d->map_data[i->y][i->x] == 'E')
				if (!is_uniq_tile(mask_to_id(d->map_data[i->y][i->x]),
					&i->tmask))
					return (0);
		}
	}
	return (1);
}

int	validate_map(t_game_data *d)
{
	t_infos	i;

	line_count(d, &i);
	make_space_for_enemies(d);
	i.y = -1;
	i.tmask = 0;
	if (!scan_map(d, &i))
		return (0);
	if (!map_leak_to_void(d, &i))
		return (0);
	if ((i.tmask & 1) == 0 || (i.tmask & 2) == 0 || !is_exit_available(d, &i))
		return (0);
	d->base_collectible = d->collectible_count;
	return (*d->exit = '0', render_world(d), 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   renderer_util.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:00:30 by morgane          #+#    #+#             */
/*   Updated: 2024/12/03 14:00:34 by morgane         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "renderer.h"

static void	*second_process_flag(char flag, t_textures *textures)
{
	if ((flag & (LEFT_SIDE_OPEN | UP_SIDE_OPEN | DOWN_SIDE_OPEN
				| RIGHT_SIDE_OPEN)) == 0)
		return (textures->wall_full_all_sides);
	else if (flag == LEFT_SIDE_OPEN + UP_SIDE_OPEN)
		return (textures->wall_corner_top_left);
	else if (flag == LEFT_SIDE_OPEN + DOWN_SIDE_OPEN)
		return (textures->wall_corner_bottom_left);
	else if (flag == LEFT_SIDE_OPEN)
		return (textures->wall_side_left);
	else if (flag == UP_SIDE_OPEN)
		return (textures->wall_side_over);
	else if (flag == DOWN_SIDE_OPEN)
		return (textures->wall_side_under);
	else
		return (textures->wall_side_right);
}

static void	*third_process_flag(char flag, t_textures *textures)
{
	if (flag == (UP_SIDE_OPEN + DOWN_SIDE_OPEN))
		return (textures->wall_two_side_top_down);
	else if (flag == LEFT_SIDE_OPEN + RIGHT_SIDE_OPEN)
		return (textures->wall_two_sides_left_right);
	else if (flag == RIGHT_SIDE_OPEN)
		return (textures->wall_side_right);
	else if (flag == UP_SIDE_OPEN + RIGHT_SIDE_OPEN)
		return (textures->wall_corner_top_right);
	else
		return (textures->wall_empty_right);
}

static void	*process_flag(char flag, t_textures *textures)
{
	if (flag <= 10)
		return (second_process_flag(flag, textures));
	else if (flag <= 20)
		return (third_process_flag(flag, textures));
	else if (flag == UP_SIDE_OPEN + LEFT_SIDE_OPEN + RIGHT_SIDE_OPEN)
		return (textures->wall_empty_bottom);
	else if (flag == RIGHT_SIDE_OPEN + DOWN_SIDE_OPEN)
		return (textures->wall_corner_bottom_right);
	else if (flag == DOWN_SIDE_OPEN + LEFT_SIDE_OPEN + RIGHT_SIDE_OPEN)
		return (textures->wall_empty_top);
	else if (flag == UP_SIDE_OPEN + RIGHT_SIDE_OPEN + DOWN_SIDE_OPEN)
		return (textures->wall_empty_left);
	else
		return (textures->wall_empty_all_sides);
}

void	*determine_best_wall_tile(t_game_data *data, int x, int y)
{
	char	flag;
	char	**map;

	flag = 0;
	map = data->map_data;
	if (x == 0 || map[y][x - 1] != '1')
		flag ^= LEFT_SIDE_OPEN;
	if (y == 0 || map[y - 1][x] != '1')
		flag ^= UP_SIDE_OPEN;
	if (y == data->map_size.y - 1 || map[y + 1][x] != '1')
		flag ^= DOWN_SIDE_OPEN;
	if (x == data->map_size.x - 1 || map[y][x + 1] != '1')
		flag ^= RIGHT_SIDE_OPEN;
	return (process_flag(flag, &data->textures));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   renderer.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:00:04 by morgane          #+#    #+#             */
/*   Updated: 2025/01/06 07:58:14 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx.h"
#include "renderer.h"
#include "so_long.h"
#include "utils.h"

void	render_world(t_game_data *data)
{
	t_vector2i	pos;

	pos.y = -1;
	while (++pos.y < data->map_size.y)
	{
		pos.x = -1;
		while (++pos.x < data->map_size.x)
			if (data->map_data[pos.y][pos.x] != '\n')
				render_tile(data, texture_from_id(data->textures,
						data->map_data[pos.y][pos.x], data, pos),
					pos.x * TILE_SCALE,
					(pos.y + (IS_BONUS * 2)) * TILE_SCALE);
	}
	set_bit(&data->game_flags, GF_NEED_WORLD_REFRESH, 0);
}

void	render_tile(t_game_data *data, void *texture, int x, int y)
{
	mlx_put_image_to_window(data->mlx, data->mlx_win, texture, x, y);
}

void	*load_texture(void *mlx, char *path)
{
	static int	scale = TILE_SCALE;

	return (mlx_xpm_file_to_image(mlx, path, &scale, &scale));
}

void	*texture_from_id(t_textures textures, char id, t_game_data *data,
			t_vector2i pos)
{
	if (id == '1')
		return (determine_best_wall_tile(data, pos.x, pos.y));
	if (id == '0')
		return (textures.ground);
	if (id == 'P')
	{
		if (data->game_flags & GF_PLAYER_M_INV_TXT)
			return (textures.player);
		return (textures.player_left);
	}
	if (id == 'C')
		return (textures.collectible);
	if (id == 'E')
		return (textures.exit);
	if (IS_BONUS && id == 'F')
		return (textures.enemy);
	return (textures.debug);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   texture_loader.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/10 13:59:03 by morgane           #+#    #+#             */
/*   Updated: 2025/01/07 07:48:43 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"
#include "renderer.h"
#include "mlx.h"
#include "ft_printf.h"

static void	generate_number_tilemap(t_game_data *data, t_textures *tiles)
{
	ft_printf("Loading fonts\n");
	tiles->nbr_zero = load_texture(data->mlx, TXT_0);
	tiles->nbr_one = load_texture(data->mlx, TXT_1);
	tiles->nbr_two = load_texture(data->mlx, TXT_2);
	tiles->nbr_three = load_texture(data->mlx, TXT_3);
	tiles->nbr_four = load_texture(data->mlx, TXT_4);
	tiles->nbr_five = load_texture(data->mlx, TXT_5);
	tiles->nbr_six = load_texture(data->mlx, TXT_6);
	tiles->nbr_seven = load_texture(data->mlx, TXT_7);
	tiles->nbr_eight = load_texture(data->mlx, TXT_8);
	tiles->nbr_nine = load_texture(data->mlx, TXT_9);
}

static void	setup_wall_textures(t_game_data *data, t_textures *tiles)
{
	ft_printf("Loading wall textures\n");
	tiles->wall_full_all_sides = load_texture(data->mlx, WALL_FULL_ALL_SIDES);
	tiles->wall_empty_all_sides = load_texture(data->mlx, WALL_EMPTY_ALL_SIDES);
	tiles->wall_side_left = load_texture(data->mlx, WALL_SIDE_LEFT);
	tiles->wall_side_under = load_texture(data->mlx, WALL_SIDE_UNDER);
	tiles->wall_side_right = load_texture(data->mlx, WALL_SIDE_RIGHT);
	tiles->wall_side_over = load_texture(data->mlx, WALL_SIDE_OVER);
	tiles->wall_corner_top_right = load_texture(data->mlx,
			WALL_CORNER_TOP_RIGHT);
	tiles->wall_corner_top_left = load_texture(data->mlx, WALL_CORNER_TOP_LEFT);
	tiles->wall_corner_bottom_right = load_texture(data->mlx,
			WALL_CORNER_BOTTOM_RIGHT);
	tiles->wall_corner_bottom_left = load_texture(data->mlx,
			WALL_CORNER_BOTTOM_LEFT);
	tiles->wall_two_sides_left_right = load_texture(data->mlx,
			WALL_TWO_SIDES_LEFT_RIGHT);
	tiles->wall_two_side_top_down = load_texture(data->mlx,
			WALL_TWO_SIDE_TOP_DOWN);
	tiles->wall_empty_bottom = load_texture(data->mlx, WALL_EMPTY_BOTTOM);
	tiles->wall_empty_left = load_texture(data->mlx, WALL_EMPTY_LEFT);
	tiles->wall_empty_top = load_texture(data->mlx, WALL_EMPTY_TOP);
}

static void	load_game_textures(t_game_data *data, t_textures *tiles)
{
	static int	scale = 32;

	tiles->player = load_texture(data->mlx, PLAYER_TEXTURE);
	tiles->player_left = load_texture(data->mlx, PLAYER_TEXTURE_FACING_LEFT);
	tiles->ground = load_texture(data->mlx, GROUND_TEXTURE);
	tiles->wall_empty_right = load_texture(data->mlx, WALL_EMPTY_RIGHT);
	tiles->collectible = load_texture(data->mlx, COLLECTIBLE_TEXTURE);
	tiles->exit = load_texture(data->mlx, EXIT_TEXTURE);
	tiles->enemy = load_texture(data->mlx, ENEMY_TEXTURE);
	ft_printf("Loading loading UI\n");
	tiles->slash = load_texture(data->mlx, SLASH_TEXTURE);
	tiles->step_label = mlx_xpm_file_to_image(data->mlx, STEP_LABEL_TEXTURE,
			&scale, &scale);
	tiles->collected = mlx_xpm_file_to_image(data->mlx, COLLECTED_TEXTURE,
			&scale, &scale);
}

int	setup_textures(t_game_data *data)
{
	t_textures	tile;

	ft_printf("Loading main textures\n");
	tile.debug = load_texture(data->mlx, DEBUG_TEXTURE);
	if (tile.debug == NULL)
	{
		ft_printf("Error : can't load texture (check PWD ?)\n");
		return (0);
	}
	setup_wall_textures(data, &tile);
	load_game_textures(data, &tile);
	generate_number_tilemap(data, &tile);
	data->textures = tile;
	data->game_flags ^= GF_NEED_WORLD_REFRESH;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mock_enemy_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/11 08:58:52 by morgane           #+#    #+#             */
/*   Updated: 2025/01/06 07:50:44 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"
#include "utils.h"

// #if !IS_BONUS

// do jack shit as the executable literally dont have access 
// to enemy code in mandatory mode. I would have done it differently,
// should the norm allows it
//
// ideally :
//
// void tick_enemies(t_game_data *data)
// {
// 		int	i;
//
// 		(void)data;
// 		i = -1;
// 		#if IS_BONUS
//		// yes, you can do include in method like that
//		# include "../bonus/enemy.h" 
//		while (++i < data->enemy_count)
//			process_enemy_move(data, &data->enemies[i]);
// 		#endif
// }
// 
// but hey, we do what we must
// also, not being able to do includes in method is the reason why this file
// even exist. This is fucking stupid !
void	tick_enemies(t_game_data *data)
{
	(void)data;
}

// this function should not even be called outside of BONUS,
// but we need it anyway, as i'm pretty sure not having it will.
// break shit if my parser fuck something up.
void	spawn_enemies(t_game_data *data, t_vector2i pos)
{
	(void)data;
	(void)pos;
}

void	make_space_for_enemies(t_game_data *data)
{
	(void)data;
}

void	free_space(t_game_data *data)
{
	(void)data;
}

// #endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:01:00 by morgane          #+#    #+#             */
/*   Updated: 2025/01/06 08:56:48 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx.h"
#include "so_long.h"
#include "utils.h"
#include <stdlib.h>

int	is_valid_id(char id)
{
	if (IS_BONUS)
	{
		if (id == 'F')
			return (1);
	}
	return (id == '1' || id == '0' || id == 'P' || id == 'C' || id == 'E'
		|| id == '\n');
}

int	set_bit(int *base, int mask, int new_value)
{
	if (new_value)
		*base |= mask;
	else
		*base &= ~mask;
	return (*base);
}

int	is_valid_target_tile(t_vector2i pos, t_game_data *data)
{
	return (data->map_data[pos.y][pos.x] != '1' && pos.x < data->map_size.x
		&& pos.y < data->map_size.y);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 14:01:28 by morgane          #+#    #+#             */
/*   Updated: 2024/12/03 14:01:31 by morgane         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "so_long.h"

t_vector2i	vector_add_lit(t_vector2i base, int x, int y)
{
	base.x += x;
	base.y += y;
	return (base);
}

t_vector2i	vector_add(t_vector2i base, int flag)
{
	if (flag == 0)
		base.x += 1;
	else if (flag == 1)
		base.x -= 1;
	if (flag == 2)
		base.y += 1;
	else if (flag == 3)
		base.y -= 1;
	return (base);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   asset_cleaner.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/06 13:32:35 by morgane           #+#    #+#             */
/*   Updated: 2025/01/07 08:14:00 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
#include "so_long.h"
#include "mlx.h"
#include "utils.h"
#include <stdlib.h>

void	unload_font(t_game_data *data)
{
	ft_printf("Deleting font\n");
	mlx_destroy_image(data->mlx, data->textures.nbr_zero);
	mlx_destroy_image(data->mlx, data->textures.nbr_one);
	mlx_destroy_image(data->mlx, data->textures.nbr_two);
	mlx_destroy_image(data->mlx, data->textures.nbr_three);
	mlx_destroy_image(data->mlx, data->textures.nbr_four);
	mlx_destroy_image(data->mlx, data->textures.nbr_five);
	mlx_destroy_image(data->mlx, data->textures.nbr_six);
	mlx_destroy_image(data->mlx, data->textures.nbr_seven);
	mlx_destroy_image(data->mlx, data->textures.nbr_eight);
	mlx_destroy_image(data->mlx, data->textures.nbr_nine);
}

static void	delete_walls(t_game_data *data)
{
	ft_printf("Deleting ground tiles\n");
	mlx_destroy_image(data->mlx, data->textures.wall_full_all_sides);
	mlx_destroy_image(data->mlx, data->textures.wall_empty_all_sides);
	mlx_destroy_image(data->mlx, data->textures.wall_side_left);
	mlx_destroy_image(data->mlx, data->textures.wall_side_under);
	mlx_destroy_image(data->mlx, data->textures.wall_side_right);
	mlx_destroy_image(data->mlx, data->textures.wall_side_over);
	mlx_destroy_image(data->mlx, data->textures.wall_corner_top_right);
	mlx_destroy_image(data->mlx, data->textures.wall_corner_top_left);
	mlx_destroy_image(data->mlx, data->textures.wall_corner_bottom_right);
	mlx_destroy_image(data->mlx, data->textures.wall_corner_bottom_left);
	mlx_destroy_image(data->mlx, data->textures.wall_two_sides_left_right);
	mlx_destroy_image(data->mlx, data->textures.wall_two_side_top_down);
	mlx_destroy_image(data->mlx, data->textures.wall_empty_bottom);
	mlx_destroy_image(data->mlx, data->textures.wall_empty_left);
	mlx_destroy_image(data->mlx, data->textures.wall_empty_top);
	mlx_destroy_image(data->mlx, data->textures.wall_empty_right);
}

static void	delete_textures(t_game_data *data)
{
	ft_printf("Deleting game textures\n");
	mlx_destroy_image(data->mlx, data->textures.player);
	mlx_destroy_image(data->mlx, data->textures.player_left);
	mlx_destroy_image(data->mlx, data->textures.ground);
	mlx_destroy_image(data->mlx, data->textures.collectible);
	mlx_destroy_image(data->mlx, data->textures.exit);
	mlx_destroy_image(data->mlx, data->textures.debug);
	mlx_destroy_image(data->mlx, data->textures.enemy);
	mlx_destroy_image(data->mlx, data->textures.step_label);
	mlx_destroy_image(data->mlx, data->textures.collected);
	mlx_destroy_image(data->mlx, data->textures.slash);
	delete_walls(data);
	unload_font(data);
}

void	clean_up(t_game_data *data, int before_init)
{
	static int	index = -1;

	ft_printf("Cleaning up my closet\n");
	if (before_init >= 0)
		delete_textures(data);
	if (before_init == 0)
	{
		ft_printf("deleting the window\n");
		mlx_destroy_window(data->mlx, data->mlx_win);
		data->mlx_win = NULL;
	}
	ft_printf("Deleting MLX context\n");
	mlx_destroy_display(data->mlx);
	free(data->mlx);
	if (before_init != -1)
	{
		ft_printf("Deleting game data\n");
		free_space(data);
		while (++index < (int)data->map_size.y)
			free(data->map_data[index]);
		free(data->map_data);
	}
	ft_printf("everything was cleared properly, we can exit !\n");
	exit(0);
}

int	int_c_up(t_game_data *data)
{
	clean_up(data, 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mock_bonus_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/06 14:13:03 by morgane           #+#    #+#             */
/*   Updated: 2025/01/06 14:13:32 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "score.h"

void	draw_score(t_game_data *data)
{
	(void)data;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/07 08:00:10 by morgane           #+#    #+#             */
/*   Updated: 2025/01/07 08:20:51 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
#include "so_long.h"
#include "utils.h"

int	ft_error(char *error, int status, t_game_data *data)
{
	ft_printf("\nError\n");
	ft_printf("%s\n\n", error);
	if (status != -2)
		clean_up(data, status);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   player.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/03 13:59:28 by morgane          #+#    #+#             */
/*   Updated: 2025/01/06 16:21:41 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
#include "player.h"
#include "so_long.h"
#include "utils.h"

/**
 *	Util function that do stuff based on player inputs.

	tile_after_player_move : the tile the player moved to if
		it's a valid tile to stand on

	note : GF_GAME_OBJECTIVE_WON being used for player loss
	is intentional, as both close the game in the same way.
 */
void	action(t_game_data *data, char tile_after_player_move)
{
	if (tile_after_player_move == 'C')
	{
		--data->collectible_count;
		ft_printf("player has collected a collectible\n");
	}
	if (data->collectible_count == 0)
		*data->exit = 'E';
	else
		*data->exit = '0';
	if (*data->exit == 'E' && tile_after_player_move == 'E')
	{
		set_bit(&data->game_flags, GF_GAME_OBJECTIVE_WON, 1);
		ft_printf("player, your winner !\n");
	}
	if (tile_after_player_move == 'F')
	{
		ft_printf("player lost !\n");
		set_bit(&data->game_flags, GF_GAME_OBJECTIVE_WON, 1);
	}
}

static void	update_player_pos_part_2(t_game_data *data, t_vector2i *old_pos)
{
	if (data->game_flags & GF_PLAYER_M_DIR)
	{
		if (!(data->game_flags & GF_PLAYER_M_INV))
		{
			if (is_valid_target_tile(vector_add(data->player_pos, 1), data))
				data->player_pos.x -= 1;
		}
		else if (is_valid_target_tile(vector_add(data->player_pos, 0), data))
			data->player_pos.x += 1;
	}
	action(data, data->map_data[data->player_pos.y][data->player_pos.x]);
	if (old_pos->x != data->player_pos.x || old_pos->y != data->player_pos.y)
	{
		data->map_data[data->player_pos.y][data->player_pos.x] = 'P';
		data->map_data[old_pos->y][old_pos->x] = '0';
		set_bit(&data->game_flags, GF_NEED_WORLD_REFRESH, 1);
	}
	else
		set_bit(&data->game_flags, GF_PLAYER_IS_MOVING, 0);
}

void	update_player_pos(t_game_data *data)
{
	t_vector2i	old_pos;

	if (!data->can_step)
		return ;
	old_pos = data->player_pos;
	if (!(data->game_flags & GF_PLAYER_M_DIR))
	{
		if (!(data->game_flags & GF_PLAYER_M_INV))
		{
			if (is_valid_target_tile(vector_add(data->player_pos, 3), data))
				data->player_pos.y -= 1;
		}
		else if (is_valid_target_tile(vector_add(data->player_pos, 2), data))
			data->player_pos.y += 1;
	}
	update_player_pos_part_2(data, &old_pos);
}

void	figure_out_player_pos(t_game_data *data)
{
	int	x;
	int	y;

	y = -1;
	while (++y < data->map_size.y)
	{
		x = -1;
		while (++x < data->map_size.x)
		{
			if (data->map_data[y][x] == 'P')
			{
				ft_printf("found player at x:%d, y:%d\n", x, y);
				data->player_pos.x = x;
				data->player_pos.y = y;
				return ;
			}
		}
	}
	ft_printf("WHERE THE FUCK IS THE PLAYER ?!\n");
}

void	handle_player_inputs(int keycode, t_game_data *data)
{
	set_bit(&data->game_flags, GF_PLAYER_IS_MOVING, 1);
	if (keycode == UP_W || keycode == UP_W_A)
		set_bit(&data->game_flags, GF_PLAYER_M_DIR | GF_PLAYER_M_INV,
			0);
	else if (keycode == UP_S || keycode == UP_S_A)
	{
		set_bit(&data->game_flags, GF_PLAYER_M_DIR, 0);
		set_bit(&data->game_flags, GF_PLAYER_M_INV, 1);
	}
	else if (keycode == UP_A || keycode == UP_A_A)
	{
		set_bit(&data->game_flags, (GF_NEED_WORLD_REFRESH
				| GF_PLAYER_M_DIR), 1);
		set_bit(&data->game_flags, (GF_PLAYER_M_INV | GF_PLAYER_M_INV_TXT), 0);
	}
	else if (keycode == UP_D || keycode == UP_D_A)
		set_bit(&data->game_flags,
			GF_NEED_WORLD_REFRESH | GF_PLAYER_M_INV_TXT
			| GF_PLAYER_M_INV | GF_PLAYER_M_DIR,
			1);
	else
		set_bit(&data->game_flags, GF_PLAYER_IS_MOVING, 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   enemy_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/11 09:45:35 by morgane           #+#    #+#             */
/*   Updated: 2025/01/06 13:54:39 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "enemy.h"
#include "so_long.h"
#include "utils.h"
#include <stdlib.h>
#include "ft_printf.h"

void	tick_enemies(t_game_data *data)
{
	int	i;

	if (data->enemy_count == 0)
		return ;
	i = -1;
	while (++i < data->enemy_count)
	{
		process_enemy_move(data, &data->enemies[i]);
	}
	set_bit(&data->game_flags, GF_NEED_WORLD_REFRESH, 1);
}

// yes, this wrap the enemy.c#spawn_enemy method
// yes this is stupid.
void	spawn_enemies(t_game_data *data, t_vector2i pos)
{
	spawn_enemy(data, pos);
}

void	init_data_enemy_space(t_game_data *data)
{
	if (data->enemy_count != 0)
		data->enemies = (t_enemy *)malloc(
				sizeof(t_enemy) * (data->enemy_count));
	else
		data->enemies = NULL;
}

void	make_space_for_enemies(t_game_data *data)
{
	init_data_enemy_space(data);
}

void	free_space(t_game_data *data)
{
	if (data->enemy_count != 0)
		free(data->enemies);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   enemy.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/10 13:44:36 by morgane           #+#    #+#             */
/*   Updated: 2025/01/06 13:55:23 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "enemy.h"
#include "player.h"
#include "so_long.h"
#include "utils.h"

static void	move(t_game_data *data, t_enemy *enemy, t_vector2i pos)
{
	data->map_data[pos.y][pos.x] = 'F';
	data->map_data[enemy->pos.y][enemy->pos.x] = '0';
	enemy->pos = pos;
}

static void	_internal_move(t_game_data *data, t_enemy *enemy, t_vector2i pos)
{
	if ((enemy->dir & IS_MOVING_INVERTED_BIT) != 0)
	{
		if (data->map_data[pos.y][pos.x + 1] != '1')
			move(data, enemy, vector_add_lit(pos, 1, 0));
		else
			set_bit(&enemy->dir, IS_MOVING_INVERTED_BIT, 0);
		return ;
	}
	if (data->map_data[pos.y][pos.x - 1] != '1')
		move(data, enemy, vector_add_lit(pos, -1, 0));
	else
		set_bit(&enemy->dir, IS_MOVING_INVERTED_BIT, 1);
}

static void	internal_move(t_game_data *data, t_enemy *enemy, t_vector2i pos)
{
	if ((enemy->dir & MOVE_Y_BIT) != 0)
	{
		if ((enemy->dir & IS_MOVING_INVERTED_BIT) != 0)
		{
			if (data->map_data[pos.y + 1][pos.x] != '1')
				move(data, enemy, vector_add_lit(pos, 0, 1));
			else
				set_bit(&enemy->dir, IS_MOVING_INVERTED_BIT, 0);
			return ;
		}
		if (data->map_data[pos.y - 1][pos.x] != '1')
			move(data, enemy, vector_add_lit(pos, 0, -1));
		else
			set_bit(&enemy->dir, IS_MOVING_INVERTED_BIT, 1);
		return ;
	}
	_internal_move(data, enemy, pos);
}

void	process_enemy_move(t_game_data *data, t_enemy *enemy)
{
	t_vector2i	pos;

	if (data->enemy_count == 0)
		return ;
	if (--enemy->mercy_frame > 0)
		return ;
	pos = enemy->pos;
	enemy->mercy_frame = ENEMY_WAIT_FRAME;
	internal_move(data, enemy, pos);
	action(data, data->map_data[data->player_pos.y][data->player_pos.x]);
}

int	spawn_enemy(t_game_data *data, t_vector2i pos)
{
	static int	total = 0;
	t_enemy		enemy;

	if (total >= data->enemy_count)
		return (1);
	enemy.pos = pos;
	enemy.speed = ENEMY_DEFAULT_SPEED;
	if (data->map_data[pos.y + 1][pos.x] == '1' ||
		data->map_data[pos.y - 1][pos.x] == '1')
		set_bit(&enemy.dir, MOVE_Y_BIT, 1);
	else
		set_bit(&enemy.dir, MOVE_Y_BIT, 0);
	enemy.mercy_frame = ENEMY_WAIT_FRAME;
	if (enemy.dir == -1)
		return (0);
	data->enemies[total] = enemy;
	++total;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   score.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/06 07:58:30 by morgane           #+#    #+#             */
/*   Updated: 2025/01/07 07:49:46 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "score.h"
#include "mlx.h"
#include "so_long.h"
#include "libft.h"
#include <stdlib.h>

// this is so fucking stupid that 
// i'd rather do JS than explain why it even exist
static void	*get_texture_from_char(t_game_data *data, char number)
{
	if (number == '0')
		return (data->textures.nbr_zero);
	if (number == '1')
		return (data->textures.nbr_one);
	if (number == '2')
		return (data->textures.nbr_two);
	if (number == '3')
		return (data->textures.nbr_three);
	if (number == '4')
		return (data->textures.nbr_four);
	if (number == '5')
		return (data->textures.nbr_five);
	if (number == '6')
		return (data->textures.nbr_six);
	if (number == '7')
		return (data->textures.nbr_seven);
	if (number == '8')
		return (data->textures.nbr_eight);
	if (number == '9')
		return (data->textures.nbr_nine);
	return (data->textures.slash);
}

static void	draw_steps(t_game_data *data, int value, t_vector2i *coo)
{
	char	*score_as_text;
	int		index;
	void	*tx;

	if (value < 0)
		value = 0;
	score_as_text = ft_itoa(value);
	index = -1;
	while (score_as_text[++index])
	{
		tx = get_texture_from_char(data, score_as_text[index]);
		coo->x += (index * 26);
		mlx_put_image_to_window(data->mlx, data->mlx_win, tx, coo->x, coo->y);
	}
	free(score_as_text);
}

static void	draw_collectible(t_game_data *data)
{
	t_vector2i	origin;
	int			collectible_left;
	void		*slash;

	origin.x = 250;
	origin.y = 32;
	slash = data->textures.slash;
	mlx_put_image_to_window(data->mlx, data->mlx_win,
		data->textures.collected, 0, 32);
	collectible_left = data->base_collectible - data->collectible_count;
	draw_steps(data, collectible_left, &origin);
	origin.x += 26;
	mlx_put_image_to_window(data->mlx, data->mlx_win, slash, origin.x, 32);
	origin.x += 26;
	draw_steps(data, data->base_collectible, &origin);
}

void	draw_score(t_game_data *data)
{
	t_vector2i	origin;

	origin.x = 250;
	origin.y = 0;
	mlx_put_image_to_window(data->mlx, data->mlx_win,
		data->textures.step_label, 0, 0);
	draw_steps(data, data->player_step, &origin);
	draw_collectible(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:16:42 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:16:46 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_isspace(const char chr)
{
	return (chr == ' ' || chr == '\n' || chr == '\t' || chr == '\v'
		|| chr == '\f' || chr == '\r');
}

int	ft_atoi(const char *str)
{
	long	result;
	int		sign;

	result = 0;
	sign = 1;
	while (ft_isspace(*str))
		str++;
	while (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign *= -1;
		str++;
		if (*str == '-' || *str == '+')
			return (0);
	}
	while (*str && ft_isdigit(*str))
		result = result * 10 + *str++ - '0';
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:16:58 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:17:01 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_bzero(void *s, size_t size)
{
	ft_memset(s, '\0', size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:17:17 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:17:19 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

void	*ft_calloc(size_t count, size_t size)
{
	void	*val;
	size_t	total;

	total = count * size;
	if ((count > 0) && (size > total / count))
		return (NULL);
	val = malloc(total);
	if (!val)
		return (NULL);
	ft_bzero(val, total);
	return (val);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:17:28 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:17:32 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int chr)
{
	return (ft_isdigit(chr) || ft_isalpha(chr));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:21:53 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:21:56 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:22:13 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:22:15 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	return (c >= 0 && c <= 127);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:22:24 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:22:26 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int chr)
{
	return (chr >= '0' && chr <= '9');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                    +#+  +:+       +#+      */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/28 08:57:36 by morgane          #+#    #+#              */
/*   Updated: 2024/12/12 09:20:34 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

int	ft_isprint(char s)
{
	if (s >= 32 && s <= 126)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:22:36 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:22:37 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdio.h>
#include <stdlib.h>

static int	nb_size(long n)
{
	int	size;

	size = 0;
	while (n != 0)
	{
		n /= 10;
		++size;
	}
	return (size);
}

static long	gaset_absolute(long *n)
{
	if (*n < 0)
	{
		*n = -*n;
		return (1);
	}
	return (0);
}

static void	iter_through_long(long n, char *buffer, size_t max, int sign)
{
	max -= sign;
	--max;
	if (sign)
		buffer[0] = '-';
	while (n != 0)
	{
		buffer[max - 1 + sign] = (char)(n % 10) + '0';
		n /= 10;
		--max;
	}
}

char	*ft_itoa(int n)
{
	char	*buffer;
	long	number;
	int		sign;

	if (n == 0)
		return (ft_strdup("0"));
	number = (long)n;
	sign = gaset_absolute(&number);
	buffer = (char *)malloc(sizeof(char) * (nb_size(number) + 1 + sign));
	if (!buffer)
		return (NULL);
	iter_through_long(number, buffer, nb_size(number) + 1 + sign, sign);
	buffer[nb_size(number) + sign] = '\0';
	return (buffer);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:23:47 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:23:49 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t size)
{
	while (size--)
	{
		if (*((unsigned char *)s) == (unsigned char)c)
			return ((void *)s);
		++s;
	}
	return ((void *)0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:23:59 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:24:01 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_memcmp(const void *s, const void *s2, size_t n)
{
	size_t			i;
	unsigned char	*ss1;
	unsigned char	*ss2;

	ss1 = (unsigned char *)s;
	ss2 = (unsigned char *)s2;
	i = 0;
	while (i < n)
	{
		if ((unsigned char)ss1[i] != (unsigned char)ss2[i])
			return ((unsigned char)ss1[i] - (unsigned char)ss2[i]);
		++i;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:24:11 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:24:13 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdio.h>

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char	*tmp;

	if (!dest && !src)
		return (NULL);
	tmp = (unsigned char *)dest;
	while (n-- != 0)
	{
		*(unsigned char *)tmp = *(unsigned char *)src;
		++tmp;
		++src;
	}
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:24:36 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:24:37 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	char		*d;
	const char	*c;
	size_t		index;

	if (!dest && !src)
		return (0);
	d = (char *)dest;
	c = (const char *)src;
	index = -1;
	if (d < c)
		while (++index < n)
			d[index] = c[index];
	else
		while (n-- > 0)
			d[n] = c[n];
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:24:57 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:25:00 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>

void	*ft_memset(void *s, int c, size_t n)
{
	unsigned char	*tmp;

	++n;
	tmp = s;
	while (--n > 0)
		*tmp++ = (unsigned char)c;
	return (s);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:27:11 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:27:12 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	handle_args(const char *str, va_list args)
{
	int	current_size;

	current_size = 0;
	if (str[0] == 'c')
		current_size += handle_char(args);
	else if (str[0] == '%')
		current_size += handle_perc(args);
	else if (str[0] == 's')
		current_size += handle_stri(args);
	else if (str[0] == 'p')
		current_size += handle_ptrs(args);
	else if (str[0] == 'd' || str[0] == 'i')
		current_size += handle_nbrs(args);
	else if (str[0] == 'u')
		current_size += handle_unbr(args);
	else if (str[0] == 'x')
		current_size += handle_hexl(args);
	else if (str[0] == 'X')
		current_size += handle_hexu(args);
	return (current_size);
}

int	ft_printf(const char *str, ...)
{
	int		str_size;
	int		index;
	va_list	args;

	va_start(args, str);
	index = -1;
	str_size = 0;
	if (ft_strchr(str, '%') == NULL)
		return (ft_putstr_fd((char *)str, STANDARD_OUTPUT_FD), ft_strlen(str));
	while (str[++index])
	{
		if (str[index] == '%')
			str_size += handle_args(&str[++index], args);
		else
		{
			ft_putchar_fd(str[index], STANDARD_OUTPUT_FD);
			++str_size;
		}
	}
	return (str_size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_handle_basics.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:27:40 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:27:41 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

int	handle_char(va_list args)
{
	ft_putchar_fd((char)va_arg(args, int), STANDARD_OUTPUT_FD);
	return (1);
}

int	handle_perc(va_list args)
{
	(void)args;
	ft_putchar_fd('%', STANDARD_OUTPUT_FD);
	return (1);
}

int	handle_stri(va_list args)
{
	char	*to_print;

	to_print = va_arg(args, char *);
	if (to_print == NULL)
	{
		ft_putstr_fd("(null)", STANDARD_OUTPUT_FD);
		return (6);
	}
	ft_putstr_fd(to_print, STANDARD_OUTPUT_FD);
	return (ft_strlen(to_print));
}

int	handle_nbrs(va_list args)
{
	char	*to_print;
	int		str_size;

	to_print = ft_itoa(va_arg(args, int));
	str_size = ft_strlen(to_print);
	ft_putstr_fd(to_print, STANDARD_OUTPUT_FD);
	free(to_print);
	return (str_size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_handle_complex.c                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:21:23 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:21:29 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"
#include "stdint.h"

static int	print_hexa(unsigned long num)
{
	int	size;

	size = 0;
	if (num >= 16)
	{
		size += print_hexa(num / 16);
		size += print_hexa(num % 16);
	}
	else
	{
		if (num <= 9)
			ft_putchar_fd(num + '0', STANDARD_OUTPUT_FD);
		else
			ft_putchar_fd(num - 10 + 'a', STANDARD_OUTPUT_FD);
		++size;
	}
	return (size);
}

int	handle_ptrs(va_list args)
{
	unsigned long	ptr;

	ptr = va_arg(args, unsigned long);
	if (ptr == 0)
		return (ft_putstr_fd("(nil)", STANDARD_OUTPUT_FD), ft_strlen("(nil)"));
	ft_putstr_fd("0x", STANDARD_OUTPUT_FD);
	return (print_hexa(ptr) + 2);
}

int	handle_unbr(va_list args)
{
	unsigned int	value;
	unsigned int	str_size;
	char			*to_print;

	value = va_arg(args, unsigned int);
	to_print = ft_uitoa(value);
	ft_putstr_fd(to_print, STANDARD_OUTPUT_FD);
	str_size = ft_strlen(to_print);
	free(to_print);
	return (str_size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_handle_hexa.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:27:58 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:27:59 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

static int	print_hexa(unsigned int num, int is_upper)
{
	int	size;

	size = 0;
	if (num >= 16)
	{
		size += print_hexa(num / 16, is_upper);
		size += print_hexa(num % 16, is_upper);
	}
	else
	{
		if (num <= 9)
			ft_putchar_fd(num + '0', STANDARD_OUTPUT_FD);
		else
		{
			if (is_upper)
				ft_putchar_fd(num - 10 + 'A', STANDARD_OUTPUT_FD);
			else
				ft_putchar_fd(num - 10 + 'a', STANDARD_OUTPUT_FD);
		}
		++size;
	}
	return (size);
}

int	handle_hexl(va_list args)
{
	return (print_hexa(va_arg(args, unsigned int), 0));
}

int	handle_hexu(va_list args)
{
	return (print_hexa(va_arg(args, unsigned int), 1));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:28:14 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:28:16 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <unistd.h>

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:28:28 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:28:30 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	ft_putstr_fd(s, fd);
	ft_putchar_fd('\n', fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:28:44 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:28:45 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	long	tmp;

	tmp = (long)n;
	if (tmp < 0)
	{
		tmp = -tmp;
		ft_putchar_fd('-', fd);
	}
	if (tmp >= 10)
	{
		ft_putnbr_fd(tmp / 10, fd);
		ft_putnbr_fd(tmp % 10, fd);
	}
	else
		ft_putchar_fd(tmp + '0', fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:28:55 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:28:56 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <unistd.h>

void	ft_putstr_fd(char *s, int fd)
{
	write(fd, s, ft_strlen(s));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:29:06 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:29:15 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

static char	*populate(const char *str, int start, int end)
{
	char	*word;
	int		i;

	i = 0;
	word = malloc((end - start + 1) * sizeof(char));
	if (!word)
		return (NULL);
	while (start < end)
	{
		word[i] = str[start];
		i++;
		start++;
	}
	word[i] = 0;
	return (word);
}

static int	count_words(const char *str, char c)
{
	int	count;
	int	found;

	count = 0;
	found = 0;
	while (*str)
	{
		if (*str != c && !found)
		{
			found = 1;
			count++;
		}
		else if (*str == c)
			found = 0;
		str++;
	}
	return (count);
}

static void	*ft_free(char **strs, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		free(strs[i]);
		i++;
	}
	free(strs);
	return (NULL);
}

static void	reset(size_t *index, int *count, int *start_word)
{
	*index = 0;
	*count = 0;
	*start_word = -1;
}

char	**ft_split(const char *s, char c)
{
	char	**res;
	size_t	index;
	int		count;
	int		start_word;

	reset(&index, &count, &start_word);
	res = ft_calloc((count_words(s, c) + 1), sizeof(char *));
	if (!res)
		return (NULL);
	while (index <= ft_strlen(s))
	{
		if (s[index] != c && start_word < 0)
			start_word = index;
		else if ((s[index] == c || index == ft_strlen(s)) && start_word >= 0)
		{
			res[count] = populate(s, start_word, index);
			if (!(res[count]))
				return (ft_free(res, count));
			start_word = -1;
			++count;
		}
		++index;
	}
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:29:33 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:29:52 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strchr(const char *s1, int s2)
{
	while (*s1 != '\0')
	{
		if (*s1 == (char)s2)
			return ((char *)s1);
		++s1;
	}
	if (*s1 == (char)s2)
		return ((char *)s1);
	return ((void *)0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:30:05 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:30:07 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

char	*ft_strdup(char *src)
{
	char	*target;

	target = (char *)malloc(sizeof(char) * (ft_strlen(src) + 1));
	if (!target)
		return (NULL);
	ft_strlcpy(target, src, ft_strlen(src) + 1);
	return (target);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:30:16 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:30:18 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	size_t	index;

	index = 0;
	if (*s)
	{
		while (*s)
		{
			f(index, s);
			++index;
			++s;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:30:29 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:30:30 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*linked;
	int		size_s1;
	int		size_s2;
	int		index;

	size_s1 = ft_strlen((char *)s1);
	size_s2 = ft_strlen((char *)s2);
	linked = (char *)malloc(sizeof(char) * (size_s1 + size_s2 + 1));
	if (!linked)
		return (NULL);
	index = 0;
	while (*s1)
		linked[index++] = *s1++;
	while (*s2)
		linked[index++] = *s2++;
	linked[index] = '\0';
	return (linked);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:30:45 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:30:46 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)
{
	size_t	src_len;
	size_t	dst_len;

	src_len = ft_strlen(src);
	dst_len = ft_strlen(dst);
	if (dst_len >= dstsize)
		dst_len = dstsize;
	if (dst_len == dstsize)
		return (dstsize + src_len);
	if (src_len < dstsize - dst_len)
		ft_memcpy(dst + dst_len, src, src_len + 1);
	else
	{
		ft_memcpy(dst + dst_len, src, dstsize - dst_len - 1);
		dst[dstsize - 1] = '\0';
	}
	return (dst_len + src_len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:30:55 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:30:59 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlcpy(char *dest, const char *src, size_t size)
{
	size_t	len;

	len = (size_t)ft_strlen((char *)src);
	if (len + 1 < size)
		ft_memcpy(dest, src, len + 1);
	else if (size != 0)
	{
		ft_memcpy(dest, src, size - 1);
		dest[size - 1] = '\0';
	}
	return (len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:31:09 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:31:10 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char *str)
{
	int	size;

	size = -1;
	while (str[++size])
	{
	}
	return (size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:31:19 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:31:20 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char	*result;
	int		current;

	current = 0;
	result = (char *)ft_calloc(sizeof(char), ft_strlen((char *)s) + 1);
	if (!result)
		return (NULL);
	while (*s != '\0')
	{
		result[current] = f(current, *s);
		++s;
		++current;
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:31:30 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:31:32 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while ((s1[i] || s2[i]) && i < n)
	{
		if ((unsigned char)s1[i] != (unsigned char)s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:31:41 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:31:42 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strnstr(const char *haystack, const char *needle, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	if (needle[0] == 0)
		return ((char *)haystack);
	while (haystack[i] && i < len)
	{
		while (haystack[i + j] == needle[j] && haystack[i + j] && i + j < len)
		{
			j++;
			if (needle[j] == 0)
				return ((char *)haystack + i);
		}
		i++;
		j = 0;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:31:49 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:31:50 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	char	*res;
	char	cc;

	res = NULL;
	cc = (char)c;
	while (*s)
	{
		if (*s == cc)
			res = (char *)s;
		s++;
	}
	if (cc == '\0')
		return ((char *)s);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:32:04 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:32:05 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

static int	is_trimmable(char const *set, char str_chr)
{
	int	i;

	if (!set)
		return (0);
	i = 0;
	while (set[i] != '\0')
	{
		if (set[i] == str_chr)
			return (1);
		++i;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	int		index_s1;
	int		index_s1_a;
	size_t	t_left;
	size_t	t_right;
	char	*result;

	if (ft_strlen((char *)s1) == 0)
		return (ft_strdup(""));
	index_s1 = -1;
	index_s1_a = ft_strlen((char *)s1);
	t_left = 0;
	t_right = 0;
	while (is_trimmable(set, s1[++index_s1]))
		++t_left;
	while (is_trimmable(set, s1[--index_s1_a]))
		++t_right;
	if ((int)(ft_strlen((char *)s1) - t_left - t_right) <= 0)
		return (ft_strdup(""));
	result = ft_substr(s1, t_left, ft_strlen((char *)s1) - t_left - t_right);
	if (result)
		result[ft_strlen((char *)result)] = '\0';
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:32:23 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:32:24 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

char	*ft_substr(char const *s, size_t start, size_t len)
{
	char	*buffer;
	size_t	s_len;

	if (!s)
		return (NULL);
	s_len = ft_strlen((char *)s);
	if (start >= s_len)
		return (ft_calloc(1, sizeof(char)));
	if (len > s_len - start)
		len = s_len - start;
	buffer = (char *)ft_calloc(len + 1, sizeof(char));
	if (!buffer)
		return (NULL);
	ft_strlcpy(buffer, s + start, len + 1);
	return (buffer);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:32:33 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:32:34 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int chr)
{
	if (chr >= 'A' && chr <= 'Z')
		return (chr + 32);
	return (chr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uitoa.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:32:55 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:32:56 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdlib.h>

static int	nb_size(unsigned long n)
{
	int	size;

	size = 0;
	while (n != 0)
	{
		n /= 10;
		++size;
	}
	return (size);
}

static void	iter_through_long(unsigned long n, char *buffer, size_t max)
{
	--max;
	while (n != 0)
	{
		buffer[max - 1] = (char)(n % 10) + '0';
		n /= 10;
		--max;
	}
}

char	*ft_uitoa(unsigned int n)
{
	char			*buffer;
	unsigned long	number;

	if (n == 0)
		return (ft_strdup("0"));
	number = (long)n;
	buffer = (char *)malloc(sizeof(char) * (nb_size(number) + 1));
	if (!buffer)
		return (NULL);
	iter_through_long(number, buffer, nb_size(number) + 1);
	buffer[nb_size(number)] = '\0';
	return (buffer);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ultoa.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:33:07 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:33:09 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdio.h>
#include <stdlib.h>

static int	nb_size(unsigned long n)
{
	int	size;

	size = 0;
	while (n != 0)
	{
		n /= 10;
		++size;
	}
	return (size);
}

static void	iter_through_long(unsigned long n, char *buffer, size_t max)
{
	--max;
	while (n != 0)
	{
		buffer[max - 1] = (char)(n % 10) + '0';
		n /= 10;
		--max;
	}
}

char	*ft_ultoa(unsigned long n)
{
	char			*buffer;
	unsigned long	number;

	if (n == 0)
		return (ft_strdup("0"));
	number = n;
	buffer = (char *)malloc(sizeof(char) * (nb_size(number) + 1));
	if (!buffer)
		return (NULL);
	iter_through_long(number, buffer, nb_size(number) + 1);
	buffer[nb_size(number)] = '\0';
	return (buffer);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: morgane <git@morgane.dev>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 09:37:11 by morgane           #+#    #+#             */
/*   Updated: 2024/12/12 09:37:13 by morgane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_toupper(int chr)
{
	if (chr >= 'a' && chr <= 'z')
		return (chr - 32);
	return (chr);
}
